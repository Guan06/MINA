community.similarity.corr.par <- function(o.t, S, distance="jaccard.corr.uw.norm", blocksize=1000, use.cores=80) {
	########################
	#Load packages for parallel processing
	require("plyr")
	require("foreach")
	require("bigmemory")
	library("doMC", quietly=T)
	#Register cluster
	registerDoMC(cores=use.cores)
	########################

	########################
	#Get N x 2 matrix of pairwise combinations of samples
	samples <- colnames(o.t)
	#Turn OTU table into list format
	ot.occ.list <- apply((o.t > 0), 2, which)
	#ot.count.list <- mclapply(seq(1,length(ot.occ.list)), function(i) {o.t[ot.occ.list[[i]],i]}, mc.cores=use.cores)
	ot.count.list <- alply(o.t, .margins=2, .fun=function(o.vec) {o.vec[o.vec > 0]}, .parallel=T)
	names(ot.occ.list) <- names(ot.count.list) <- samples
	########################

	########################
	#Unweighted, corrected Jaccard, normalized by sample self-comparisons
	#=> this is for unweighted TINA/PINA
	if (distance == "jaccard.corr.uw.norm") {

        #Pre-calculate sample-wise interaction term sums (normalized by number of OTUs per sample)
		smpl.colsums <- mclapply(ot.occ.list, function(a.list) {colSums(S[a.list, ]) / length(a.list)}, mc.cores=use.cores)
		names(smpl.colsums) <- samples

        #Pre-calculate sample self-comparisons
		smpl.self <- unlist(lapply(samples, function(a) {
                                        a.list <- ot.occ.list[[a]]
                                        sum(smpl.colsums[[a]][a.list]) / length(a.list)
                                        }))
		names(smpl.self) <- samples

        #Calculate similarity index in parallel
		cs.list <- mclapply(samples, function(a) {
			a.sums <- smpl.colsums[[a]]
            a.self <- smpl.self[a]
			unlist(lapply(samples, function(b) {
				b.list <- ot.occ.list[[b]]
                b.self <- smpl.self[b]
				1 - (sum(a.sums[b.list]) / (length(b.list) * sqrt(a.self*b.self)))
			}))
		}, mc.cores=use.cores)
	}
	########################
	#Weighted, corrected Jaccard, normalized by sample self-comparisons
	#=> this is for weighted TINA/PINA
	if (distance == "jaccard.corr.w.norm") {
		#Pre-calculate relative abundances per sample
		ot.rel_count <- lapply(ot.count.list, function(a.count) {a.count / sum(a.count)})
		#Pre-calculate sample self-comparisons
		smpl.self <- unlist(mclapply(ot.rel_count, function(a.rel) {
			a.list <- names(a.rel)
            a.S <- S[a.list, a.list]
			sum(a.S * outer(a.rel, a.rel))
		}, mc.cores=use.cores))
		#Iterate through samples in parallel
		cs.list <- mclapply(samples, function(a) {
			#Get current OTU names, relative counts and sample size
			a.rel <- ot.rel_count[[a]]
            a.list <- names(a.rel)
			#Get current interaction sub-matrix
			a.S <- a.rel * S[a.list,]
			#Iterate through all potential partner samples
			unlist(lapply(samples, function(b) {
				b.rel <- ot.rel_count[[b]]
                b.list <- names(b.rel)
                curr.S <- a.S[,b.list]
				#Calculate sample-pair weighted interaction term
				1 - (sum(b.rel * t(curr.S)) / sqrt(smpl.self[a] * smpl.self[b]))
			}))
		}, mc.cores=use.cores)
	}
	########################
	file.remove(list.files("/dev/shm/", full.name=T))

	#Return
	return.mat <- do.call("rbind", cs.list)
	rownames(return.mat) <- colnames(return.mat) <- samples
	return.mat
}
########################
