\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `mina'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Title]\AsIs{Microbial community dIversity and Network Analysis}
\item[Version]\AsIs{0.99.0}
\item[Description]\AsIs{An increasing number of microbiome datasets have been generated and analyzed with the help of rapidly developing sequencing technologies. At present, analysis of taxonomic profiling data is mainly conducted using composition-based methods, which ignores interactions between community members. Besides this, a lack of efficient ways to compare microbial interaction networks limited the study of community dynamics. To better understand how community diversity is affected by complex interactions between its members, we developed a framework (Microbial community dIversity and Network Analysis, MINA), a comprehensive framework for microbial community diversity analysis and network comparison. By defining and integrating network-derived community features, we greatly reduce noise-to-signal ratio for diversity analyses. A bootstrap and permutation-based method was implemented to assess community network dissimilarities and extract discriminative features in a statistically principled way.}
\item[Depends]\AsIs{R (>= 4.0.0)}
\item[LinkingTo]\AsIs{Rcpp, RcppParallel, RcppArmadillo}
\item[License]\AsIs{GPL}
\item[Encoding]\AsIs{UTF-8}
\item[Imports]\AsIs{methods, stats, Rcpp, MCL, RSpectra, apcluster, bigmemory,
doMC, foreach, ggplot2, parallel, parallelDist, reshape2, plyr,
biganalytics, stringr, Hmisc, utils}
\item[LazyData]\AsIs{true}
\item[Suggests]\AsIs{knitr, rmarkdown, testthat}
\item[VignetteBuilder]\AsIs{knitr}
\item[RoxygenNote]\AsIs{7.1.1}
\item[Collate]\AsIs{'RcppChk.R' 'RcppExports.R' 'all\_classes.R' 'all\_generics.R'
'adj.R' 'bs\_pm.R' 'check.R' 'com\_dis.R' 'com\_plot.R' 'com\_r2.R'
'data.R' 'dmr.R' 'fit\_tabs.R' 'net\_cls.R' 'net\_cls\_tab.R'
'net\_dis.R' 'net\_dis\_indi.R' 'norm\_tab.R'}
\item[biocViews]\AsIs{Software, WorkflowStep}
\item[BugReports]\AsIs{}\url{https://github.com/Guan06/MINA}\AsIs{}
\item[NeedsCompilation]\AsIs{yes}
\item[Author]\AsIs{Rui Guan [aut, cre],
Ruben Garrido-Oter [ctb]}
\item[Maintainer]\AsIs{Rui Guan }\email{guan@mpipz.mpg.de}\AsIs{}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{adj}{Calculate the adjacacency matrix of @norm by correlation.}{adj}
%
\begin{Description}\relax
Calculate the adjacacency matrix of @norm by correlation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
adj(x, method, sig = FALSE, threads = 80, nblocks = 400)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of the class mina with @norm defined.

\item[\code{method}] The correlation coeffient used for adjacacency matrix.

\item[\code{sig}] (optional) The asymtotic P-values, only applicable for Pearson and
Spearman methods.

\item[\code{threads}] (optional) The number of threads used for parallel running.

\item[\code{nblocks}] (optional) The number of row / column for splitted sub-matrix.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Adjacency matrix.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref", depth = 1000)
maize <- fit_tabs(maize)
maize <- adj(maize, method = "spearman", sig = FALSE)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{adj,matrix,ANY-method}{Calculate the adjacency matrix of @norm by correlation with matrix as input.}{adj,matrix,ANY.Rdash.method}
\aliasA{adj,matrix,character-method}{adj,matrix,ANY-method}{adj,matrix,character.Rdash.method}
%
\begin{Description}\relax
Calculate the adjacency matrix of @norm by correlation with matrix as input.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'matrix,ANY'
adj(x, method, sig = FALSE, threads = 80, nblocks = 400)

## S4 method for signature 'matrix,character'
adj(x, method, sig = FALSE, threads = 80, nblocks = 400)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An matrix for correlation/adjacency matrix calculation.

\item[\code{method}] The correlation coefficient used for adjacency matrix.

\item[\code{sig}] (optional) The asymtotic P-values, only applicable for Pearson
and Spearman methods with `mina` object as input, alwasy FALSE here.

\item[\code{threads}] The number of threads used for parallel running, 80 by
default.

\item[\code{nblocks}] The number of row/column for splitting sub-matrix, 400 by
default.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
y The adjacency matrix.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
asv_norm <- norm_tab(maize_asv2, method = "raref", depth = 1000)
asv_adj <- adj(asv_norm, method = "pearson")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{adj\_method\_list}{List of adjacency matix calculation methods/ orrelations supported in \code{\LinkA{adj}{adj}}}{adj.Rul.method.Rul.list}
\keyword{datasets}{adj\_method\_list}
%
\begin{Description}\relax
Correlation methods should be specified by exact string match.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
adj_method_list
\end{verbatim}
\end{Usage}
%
\begin{Format}
A list of character vectors.
\begin{description}

\item[pearson] 
Pearson correlation.

\item[spearman] 
Spearman correlation.

\item[sparcc] 
SparCC correlation by spearman.



\end{description}

\end{Format}
%
\begin{SeeAlso}\relax
\code{\LinkA{adj}{adj}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
? adj_method_list
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{adj,mina,ANY-method}{Calculate the adjacency matrix of @norm by correlation with `mina` class object as input.}{adj,mina,ANY.Rdash.method}
\aliasA{adj,mina,character-method}{adj,mina,ANY-method}{adj,mina,character.Rdash.method}
%
\begin{Description}\relax
Calculate the adjacency matrix of @norm by correlation with `mina` class
object as input.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina,ANY'
adj(x, method, sig = FALSE, threads = 80, nblocks = 400)

## S4 method for signature 'mina,character'
adj(x, method, sig = FALSE, threads = 80, nblocks = 400)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of the class `mina` with @norm defined.

\item[\code{method}] The correlation coefficient used for adjacency matrix.

\item[\code{sig}] The asymtotic P-values, only applicable for Pearson and Spearman
methods, FALSE by default.

\item[\code{threads}] The number of threads used for parallel running, 80 by
default.

\item[\code{nblocks}] The number of row/column for splitting sub-matrix, 400 by
default.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x The same `mina` object with @adj added.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- adj(maize, method = "spearman", sig = FALSE)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bs\_pm}{Inferring the network of different group of samples and test significance by permutation.}{bs.Rul.pm}
%
\begin{Description}\relax
Inferring the network of different group of samples and test significance by
permutation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bs_pm(
  x,
  group,
  g_size = 88,
  s_size = 30,
  rm = TRUE,
  per = 0.1,
  sig = TRUE,
  bs = 6,
  pm = 6,
  individual = FALSE,
  out_dir = "./"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @norm and @des defined.

\item[\code{group}] The column name of descriptive file @des for comparison.

\item[\code{g\_size}] The cutoff of group size used for filtering, default is 88.

\item[\code{s\_size}] The number of samples used for network inference during
bootstrap and permutation (when `sig` is TRUE), it should be smaller than
g\_size to make sure the randomness; default is 30.

\item[\code{rm}] Filtering the components present in less than `per` of the samples,
default is TRUE.

\item[\code{per}] The percentage of present samples for filtering, default is 0.1.

\item[\code{sig}] Whether to test the significance, skip the permutation when set as
FALSE, default is TRUE.

\item[\code{bs}] The times for bootstrap network inference, default is 6.

\item[\code{pm}] The times for permutation network inference, default is 6.

\item[\code{individual}] Whether to output the bootstrap and permutation results of
each comparison individually, default is FALSE.

\item[\code{out\_dir}] The output directory if `individual` is TRUE, default is the
current working directory.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The network bootstrap and permutation result.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- bs_pm(maize, group = "Compartment", per = 0.5)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bs\_pm,mina,ANY-method}{Inferring the network of different group of samples and test significance by permutation.}{bs.Rul.pm,mina,ANY.Rdash.method}
\aliasA{bs\_pm,mina,character-method}{bs\_pm,mina,ANY-method}{bs.Rul.pm,mina,character.Rdash.method}
%
\begin{Description}\relax
Inferring the network of different group of samples and test significance by
permutation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina,ANY'
bs_pm(
  x,
  group,
  g_size = 88,
  s_size = 30,
  rm = TRUE,
  per = 0.1,
  sig = TRUE,
  bs = 6,
  pm = 6,
  individual = FALSE,
  out_dir = "./"
)

## S4 method for signature 'mina,character'
bs_pm(
  x,
  group,
  g_size = 88,
  s_size = 30,
  rm = TRUE,
  per = 0.1,
  sig = TRUE,
  bs = 6,
  pm = 6,
  individual = FALSE,
  out_dir = "./"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @norm and @des defined.

\item[\code{group}] The column name of descriptive file @des for comparison.

\item[\code{g\_size}] The cutoff of group size used for filtering, default is 88.

\item[\code{s\_size}] The number of samples used for network inference during
bootstrap and permutation (when `sig` is TRUE), it should be smaller than
g\_size / 2 to make sure the randomness; default is 30.

\item[\code{rm}] Filtering the components present in less than `per` of the samples
from compared groups, default TRUE.

\item[\code{per}] The percentage of present samples for filtering, default is 0.1.

\item[\code{sig}] Whether to test the significance, skip the permutation when set as
FALSE, default is TRUE.

\item[\code{bs}] The times for bootstrap network inference, default is 6.

\item[\code{pm}] The times for permuatated samples network inference, default is 6.

\item[\code{individual}] Whether to output the bootstrap and permutation results of
each comparison individually, default is FALSE.

\item[\code{out\_dir}] The output directory if `individual` is TRUE, default is the
current working directory
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x The same object with @multi and @perm defined.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- bs_pm(maize, group = "Compartment", per = 0.5)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{check\_mina\_de}{Check the object and return TRUE if the object includes descriptive table contains the same samples as quantitative table.}{check.Rul.mina.Rul.de}
%
\begin{Description}\relax
Check the object and return TRUE if the object includes descriptive table
contains the same samples as quantitative table.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_mina_de(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class mina with @tab and @des defined.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
TRUE if the object contains non-empty descriptive table and has the
same samples as quantitative table.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
data(maize)
check_mina_de(maize)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{com\_dis}{Calculate the community dissimilarity / distance matrix of @norm.}{com.Rul.dis}
%
\begin{Description}\relax
Calculate the community dissimilarity / distance matrix of @norm.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
com_dis(x, method = "bray", threads = 80, nblocks = 400)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of the class mina with @norm defined or any quantitative
matrix.

\item[\code{method}] The dissimilarity / distance method used, default `bray`.

\item[\code{threads}] The number of threads used for parallel running, needed for
method `tina`.

\item[\code{nblocks}] The number of row / column for splitted sub-matrix, needed for
method `tina`.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The distance / dissimilarity matrix.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
asv_norm <- norm_tab(maize_asv2, method = "raref", depth = 1000)
asv_dis <- com_dis(asv_norm, method = "bray")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{com\_dis\_list}{List of dissimilarity / distance supported in \code{\LinkA{com\_dis}{com.Rul.dis}}. Dissimilarity / distance should be specified by exact string match.}{com.Rul.dis.Rul.list}
\keyword{datasets}{com\_dis\_list}
%
\begin{Description}\relax
List of dissimilarity / distance supported in \code{\LinkA{com\_dis}{com.Rul.dis}}.
Dissimilarity / distance should be specified by exact string match.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
com_dis_list
\end{verbatim}
\end{Usage}
%
\begin{Format}
A list of character vectors indicate the dissimilarity / distance
method used.

\begin{description}

\item[\code{tina}]  TINA from Schmidt\_et\_al\_2016 

\item[\code{Jaccard}]  Jaccard defined by \code{\LinkA{vegdist}{vegdist}} 

\item[weighted]  Dissimilarity / distance method for weighted matrix: 
\item[\code{bhjattacharyya}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{canberra}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{bray}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{chord}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{divergence}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{euclidean}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{fJaccard}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{geodesic}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{hellinger}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{kullback}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{manhattan}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{maximum}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{minkowski}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{podani}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{soergel}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{wave}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{whittaker}]  from \code{\LinkA{parDist}{parDist}} 

\item[unweighted]  Dissimilarity / Distance for unweighted matrix: 
\item[\code{binary}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{braun-blanquet}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{consine}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{dice}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{fager}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{faith}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{hamman}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{hamming}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{kulczynski1}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{kulczynski2}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{michael}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{mountford}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{mozley}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{ochiai}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{phi}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{russel}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{simple matching}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{simpson}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{stiles}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{tanimoto}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{yule}]  from \code{\LinkA{parDist}{parDist}} 
\item[\code{yule2}]  from \code{\LinkA{parDist}{parDist}} 


\end{description}

\end{Format}
%
\begin{Examples}
\begin{ExampleCode}
? com_dis_list
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{com\_dis,matrix,ANY-method}{Calculate the community dissimilarity / distance matrix of the input matrix.}{com.Rul.dis,matrix,ANY.Rdash.method}
\aliasA{com\_dis,matrix,character-method}{com\_dis,matrix,ANY-method}{com.Rul.dis,matrix,character.Rdash.method}
%
\begin{Description}\relax
Calculate the community dissimilarity / distance matrix of the input matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'matrix,ANY'
com_dis(x, method = "bray", threads = 80, nblocks = 400)

## S4 method for signature 'matrix,character'
com_dis(x, method = "bray", threads = 80, nblocks = 400)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A matrix of the quantitative table.

\item[\code{method}] The dissimilarity / distance method used, default `bray`.

\item[\code{threads}] (optional, only needed when method == "tina") The number of
threads used for parallel running.

\item[\code{nblocks}] (optional, only needed when method == "tina") The number of
row / column for splitted sub-matrix.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
y The dissimilarity / distance matrix.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
asv_norm <- norm_tab(maize_asv2, method = "raref", depth = 1000)
asv_dis <- com_dis(asv_norm, method = "bray")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{com\_dis,mina,ANY-method}{Calculate the community dissimilarity / distance matrix of @norm with `mina` class object as input.}{com.Rul.dis,mina,ANY.Rdash.method}
\aliasA{com\_dis,mina,character-method}{com\_dis,mina,ANY-method}{com.Rul.dis,mina,character.Rdash.method}
%
\begin{Description}\relax
Calculate the community dissimilarity / distance matrix of @norm with `mina`
class object as input.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina,ANY'
com_dis(x, method = "bray", threads = 80, nblocks = 400)

## S4 method for signature 'mina,character'
com_dis(x, method = "bray", threads = 80, nblocks = 400)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of the class `mina` with @norm defined.

\item[\code{method}] The dissimilarity / distance method used, default `bray`.

\item[\code{threads}] (optional, only needed when method == "tina") The number of
threads used for parallel running.

\item[\code{nblocks}] (optional, only needed when method == "tina") The number of
row / column for splitted sub-matrix.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x The same `mina` object with @dis added.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "total")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{com\_plot}{Visulization of components distance / dissimilarity in k dimension.}{com.Rul.plot}
%
\begin{Description}\relax
Visulization of components distance / dissimilarity in k dimension.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
com_plot(x, match, d1 = 1, d2 = 2, color, shape = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @dmr and @des defined.

\item[\code{match}] The column name of the components IDs in @des which exactly the
same indicated in @dmr.

\item[\code{d1}] The dimension be visualized in x-axis, default `1`.

\item[\code{d2}] The dimension be visualized in y-axis, default `2`.

\item[\code{color}] The column name in @des to be used for different color groups.

\item[\code{shape}] The column name in @des to be used for different shape groups,
default is `NULL`.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The PCoA plot.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref", depth = 5000)
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
maize <- dmr(maize)
p1a <- com_plot(maize, match = "Sample_ID", color = "Compartment")
p1b <- com_plot(maize, match = "Sample_ID", d1 = 3, d2 = 4,
color = "Compartment")
p2a <- com_plot(maize, match = "Sample_ID", color = "Host_genotype")
p2b <- com_plot(maize, match = "Sample_ID", d1 = 1, d2 = 3, color =
"Host_genotype")
p3a <- com_plot(maize, match = "Sample_ID", color = "Compartment", shape =
"Soil")
p3b <- com_plot(maize, match = "Sample_ID", d1 = 1, d2 = 4, color =
"Compartment", shape = "Soil")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{com\_plot,mina,ANY,ANY,ANY,ANY-method}{Visulization of components distance / dissimilarity in k dimension.}{com.Rul.plot,mina,ANY,ANY,ANY,ANY.Rdash.method}
\aliasA{com\_plot,mina,character,ANY,ANY,ANY-method}{com\_plot,mina,ANY,ANY,ANY,ANY-method}{com.Rul.plot,mina,character,ANY,ANY,ANY.Rdash.method}
\aliasA{com\_plot,mina,character,ANY,ANY,character-method}{com\_plot,mina,ANY,ANY,ANY,ANY-method}{com.Rul.plot,mina,character,ANY,ANY,character.Rdash.method}
%
\begin{Description}\relax
Visulization of components distance / dissimilarity in k dimension.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina,ANY,ANY,ANY,ANY'
com_plot(x, match, d1 = 1, d2 = 2, color, shape = NULL)

## S4 method for signature 'mina,character,ANY,ANY,ANY'
com_plot(x, match, d1 = 1, d2 = 2, color, shape = NULL)

## S4 method for signature 'mina,character,ANY,ANY,character'
com_plot(x, match, d1 = 1, d2 = 2, color, shape = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of `mina` with list @dmr defined.

\item[\code{match}] The column name of the components IDs in @des with exactly the
same as rownames in x.

\item[\code{d1}] The dimension be visualized in x-axis, default `1`.

\item[\code{d2}] The dimension be visualized in y-axis, default `2`.

\item[\code{color}] The column name in @des to be used for different color groups.

\item[\code{shape}] The column name in @des to be used for different shape groups,
default `NULL`.
shape groups.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
p The plotted figure.

The PCoA plot.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv, des = maize_des)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
maize <- dmr(maize)
p1a <- com_plot(maize, match = "Sample_ID", color = "Compartment")
p1b <- com_plot(maize, match = "Sample_ID", d1 = 3, d2 = 4,
color = "Compartment")
p2a <- com_plot(maize, match = "Sample_ID", color = "Host_genotype")
p2b <- com_plot(maize, match = "Sample_ID", d1 = 1, d2 = 3, color =
"Host_genotype")
p3a <- com_plot(maize, match = "Sample_ID", color = "Compartment", shape =
"Soil")
p3b <- com_plot(maize, match = "Sample_ID", d1 = 1, d2 = 4, color =
"Compartment", shape = "Soil")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{com\_r2}{Calculate the unexplained variance ratio using formula indicated in: Anderson, M.J. 2001. A new method for non-parametric multivariate analysis of variance. Austral Ecology, 26: 32--46.}{com.Rul.r2}
%
\begin{Description}\relax
Calculate the unexplained variance ratio using formula indicated in:
Anderson, M.J. 2001. A new method for non-parametric multivariate analysis of
variance. Austral Ecology, 26: 32--46.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
com_r2(x, group)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @dis and @des defined.

\item[\code{group}] The name(s) of column(s) defined as experimental setup group(s).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Unexplained variance ratio.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data(maize)
maize <- norm_tab(maize, method = "raref", depth = 5000)
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
com_r2(maize, group = c("Compartment", "Soil", "Host_genotype"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{com\_r2,mina,ANY-method}{Function for unexplained variance ratio calculation indicated in Anderson, M.J. 2001. A new method for non-parametric multivariate analysis of variance. Austral Ecology, 26: 32--46.}{com.Rul.r2,mina,ANY.Rdash.method}
\aliasA{com\_r2,mina,character-method}{com\_r2,mina,ANY-method}{com.Rul.r2,mina,character.Rdash.method}
%
\begin{Description}\relax
Function for unexplained variance ratio calculation indicated in
Anderson, M.J. 2001. A new method for non-parametric multivariate analysis of
variance. Austral Ecology, 26: 32--46.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina,ANY'
com_r2(x, group)

## S4 method for signature 'mina,character'
com_r2(x, group)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An mina object with @dis and @des defined.

\item[\code{group}] The name(s) of column(s) defined as experimental setup group(s).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
r2 The variance ratio cannot be explained by given groups.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
com_r2(maize, group = c("Compartment", "Soil", "Host_genotype"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{cp\_cor}{Function for correlation coefficient calculation.}{cp.Rul.cor}
%
\begin{Description}\relax
Function for correlation coefficient calculation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
cp_cor(mat)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] The input matrix for correlation calculation.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{data-hmp}{Internal testing data of HMP project, including quantitative table (hmp\_otu) and descriptive table (hmp\_des) for testing.}{data.Rdash.hmp}
\aliasA{hmp}{data-hmp}{hmp}
\keyword{data}{data-hmp}
%
\begin{Description}\relax
Internal testing data of HMP project, including quantitative table (hmp\_otu)
and descriptive table (hmp\_des) for testing.
\end{Description}
%
\begin{Examples}
\begin{ExampleCode}
data(hmp)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{data-maize}{Internal testing data of maize project, vegetative stage samples only, including quantitative table (maize\_asv.rds) and descriptive table (maize\_des.txt) for testing.}{data.Rdash.maize}
\aliasA{maize}{data-maize}{maize}
\keyword{data}{data-maize}
%
\begin{Description}\relax
Internal testing data of maize project, vegetative stage samples only,
including quantitative table (maize\_asv.rds) and descriptive table
(maize\_des.txt) for testing.
\end{Description}
%
\begin{Examples}
\begin{ExampleCode}
data(maize)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{dmr}{Dimensionality reduction of community dissimilarity / distance for visulization.}{dmr}
%
\begin{Description}\relax
Dimensionality reduction of community dissimilarity / distance for
visulization.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dmr(x, k = 2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @dis defined or a distance matrix.

\item[\code{k}] The dimension number after reduction.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The dimentionality reduction results.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
maize <- dmr(maize)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{dmr,matrix-method}{Dimensionality reduction of the distance matrix.}{dmr,matrix.Rdash.method}
%
\begin{Description}\relax
Dimensionality reduction of the distance matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'matrix'
dmr(x, k = 4)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A distance matrix.

\item[\code{k}] The number of dimensionality after reduction, 4 by default.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
y The coordinates of components indicated in distance matrix in k
dimension.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
data(maize)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
asv_dis <- maize@dis
asv_dis_dmr <- dmr(asv_dis)
asv_dis_dmr <- dmr(asv_dis, k = 4)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{dmr,mina-method}{Dimensionality reduction of the @dis included in mina.}{dmr,mina.Rdash.method}
%
\begin{Description}\relax
Dimensionality reduction of the @dis included in mina.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina'
dmr(x, k = 4)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of the class `mina` with @dis defined.

\item[\code{k}] The number of dimensionality after reduction, 4 by default.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x The same object with @dmr added.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
data(maize)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
maize <- dmr(maize)
maize <- dmr(maize, k = 4)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fit\_tabs}{Filter the quantitative and descriptive table to make them have the same samples, the intersect samples will be remained.}{fit.Rul.tabs}
%
\begin{Description}\relax
Filter the quantitative and descriptive table to make them have the same
samples, the intersect samples will be remained.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fit_tabs(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of the class mina with @tab and @des defined or a
quantitative matrix(need parameter des in this case).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Same mina object but fitted @tab and @des (as well as @norm if exist)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data(maize)
maize <- fit_tabs(maize)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fit\_tabs,mina-method}{Filter the quantitative and descriptive table to make them have the same samples, samples present in both tables are remained. If @norm table exist in the `mina` object, descriptive table will be filtered again to only keep samples present in @norm.}{fit.Rul.tabs,mina.Rdash.method}
%
\begin{Description}\relax
Filter the quantitative and descriptive table to make them have the same
samples, samples present in both tables are remained. If @norm table exist in
the `mina` object, descriptive table will be filtered again to only keep
samples present in @norm.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina'
fit_tabs(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class mina.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x The same object as input with fitted @tab, @des and @norm (if
defined).
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
{
data(maize)
maize <- fit_tabs(maize)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
}
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{get\_net\_cls\_tab}{Get the cluster table @cls\_tab from quantitative table @norm and network clustering results @cls.}{get.Rul.net.Rul.cls.Rul.tab}
%
\begin{Description}\relax
Get the cluster table @cls\_tab from quantitative table @norm and network
clustering results @cls.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_net_cls_tab(x_norm, x_cls, uw = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x\_norm}] The normalized quantitative table used for netowrk inference
and clustering.

\item[\code{x\_cls}] The network clustering table.

\item[\code{uw}] By summing up the number of present components of each cluster
instead of relative abundance, default is FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x\_cls The quantitative table with clusters in rows.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref", depth = 1000)
maize <- fit_tabs(maize)
maize_norm <- maize@norm
maize_adj <- adj(maize_norm, method = "spearman")
maize_cls <- net_cls(maize_adj, method = "ap", cutoff = 0.5)
maize_cls_tab <- get_net_cls_tab(maize_norm, maize_cls)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{get\_net\_cls\_tab,matrix,data.frame-method}{Get the cluster table @cls\_tab from quantitative table @norm and network clustering results @cls.}{get.Rul.net.Rul.cls.Rul.tab,matrix,data.frame.Rdash.method}
%
\begin{Description}\relax
Get the cluster table @cls\_tab from quantitative table @norm and network
clustering results @cls.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'matrix,data.frame'
get_net_cls_tab(x_norm, x_cls, uw = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x\_norm}] The normalized quantitative table used for netowrk inference
and clustering.

\item[\code{x\_cls}] The network clustering table.

\item[\code{uw}] By summing up the number of present components of each cluster
instead of relative abundance, default is FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x\_cls The quantitative table with clusters in rows.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref", depth = 1000)
maize <- fit_tabs(maize)
maize_norm <- maize@norm
maize_adj <- adj(maize_norm, method = "spearman")
maize_cls <- net_cls(maize_adj, method = "ap", cutoff = 0.5)
maize_cls_tab <- get_net_cls_tab(maize_norm, maize_cls)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{get\_r2}{Same function as `com\_r2` with matrix and corresponding descriptive table as input.}{get.Rul.r2}
%
\begin{Description}\relax
Same function as `com\_r2` with matrix and corresponding descriptive table as
input.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_r2(x, des, group)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Dissimilarity / distance matrix which indicate variances.

\item[\code{des}] The descriptive table of samples which define the groups.

\item[\code{group}] The name(s) of column(s) used  as experimental setup group(s) in
descriptive file.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
r2 The variance ratio cannot be explained by given groups.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
x <- maize@dis
des <- maize@des
get_r2(x, des, group = c("Compartment", "Soil"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{get\_r2,matrix,ANY,ANY-method}{Function for unexplained variance ratio calculation indicated in Anderson, M.J. 2001. A new method for non-parametric multivariate analysis of variance. Austral Ecology, 26: 32--46.}{get.Rul.r2,matrix,ANY,ANY.Rdash.method}
\aliasA{get\_r2,matrix,data.frame,ANY-method}{get\_r2,matrix,ANY,ANY-method}{get.Rul.r2,matrix,data.frame,ANY.Rdash.method}
\aliasA{get\_r2,matrix,data.frame,character-method}{get\_r2,matrix,ANY,ANY-method}{get.Rul.r2,matrix,data.frame,character.Rdash.method}
%
\begin{Description}\relax
Function for unexplained variance ratio calculation indicated in
Anderson, M.J. 2001. A new method for non-parametric multivariate analysis of
variance. Austral Ecology, 26: 32--46.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'matrix,ANY,ANY'
get_r2(x, des, group)

## S4 method for signature 'matrix,data.frame,ANY'
get_r2(x, des, group)

## S4 method for signature 'matrix,data.frame,character'
get_r2(x, des, group = c("Host_genotype", "Compartment", "Soil", "Management"))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Dissimilarity / distance matrix which indicate variances.

\item[\code{des}] The descriptive table of samples which define the groups.

\item[\code{group}] The name(s) of column(s) used  as experimental setup group(s) in
descriptive file.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
r2 The variance ratio cannot be explained by given groups.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
x <- maize@dis
des <- maize@des
get_r2(x, des, group = c("Compartment", "Soil"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{hmp\_des}{Design file for HMP project, including 2711 samples in total.}{hmp.Rul.des}
%
\begin{Description}\relax
Design file for HMP project, including 2711 samples in total.
\end{Description}
%
\begin{Format}
A data frame with columns:
\begin{description}

\item[Sample\_ID] The unique ID of the microbial profiling sample.
\item[Sex] The gender of the host human.
\item[Run\_center] The lab proccessing the sample sequencing.
\item[Subsite] The subsite of body where samples were collected.
\item[Site] The site of body where samples were collectec.
\item[Description] The further details about the samples.

\end{description}

\end{Format}
%
\begin{Source}\relax
HMP project.
\end{Source}
%
\begin{Examples}
\begin{ExampleCode}
data(hmp_des)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{hmp\_otu}{OTU table of HMP project, data downloaded from https://www.hmpdacc.org/hmp/HMQCP/}{hmp.Rul.otu}
%
\begin{Description}\relax
OTU table of HMP project, data downloaded from
https://www.hmpdacc.org/hmp/HMQCP/
\end{Description}
%
\begin{Format}
A matrix with samples in columns and OTUs in rows.
\end{Format}
%
\begin{Source}\relax
HMP project.
\end{Source}
%
\begin{Examples}
\begin{ExampleCode}
data(hmp_otu)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{maize\_asv}{ASV table of maize project, vegetative stage samples only.}{maize.Rul.asv}
%
\begin{Description}\relax
ASV table of maize project, vegetative stage samples only.
\end{Description}
%
\begin{Format}
A matrix with samples in columns and ASVs in rows. Unormalized table
including 12765 ASVs from 420 samples.
\end{Format}
%
\begin{Source}\relax
RECONSTRUCT project, maize microbiome part.
\end{Source}
%
\begin{Examples}
\begin{ExampleCode}
data(maize_asv)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{maize\_asv2}{Subset of ASV table of maize project, ASVs appear in less than 100 samples were filtered for later analysis.}{maize.Rul.asv2}
%
\begin{Description}\relax
Subset of ASV table of maize project, ASVs appear in less than 100 samples
were filtered for later analysis.
\end{Description}
%
\begin{Format}
A matrix with samples in columns and ASVs in rows. Unormalized table
including 1219 ASVs from 313 samples.
\end{Format}
%
\begin{Source}\relax
RECONSTRUCT project, maize microbiome part.
\end{Source}
%
\begin{Examples}
\begin{ExampleCode}
data(maize_asv2)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{maize\_des}{Design file of maize project, vegetative stage samples only, including 528 samples in total.}{maize.Rul.des}
%
\begin{Description}\relax
Design file of maize project, vegetative stage samples only, including 528
samples in total.
\end{Description}
%
\begin{Format}
A data frame with columns:
\begin{description}

\item[Sample\_ID] The unique ID of the microbial profiling sample.
\item[Host\_genotype] The genotype of the plant host maize.
\item[Compartment] The compartment of the microbial sample comes from.
\item[Soil] The soil of the sampled microbiome.
\item[Management] The management of the soil where microbial sample from.

\end{description}

\end{Format}
%
\begin{Source}\relax
RECONSTRUCT project, maize microbiome part.
\end{Source}
%
\begin{Examples}
\begin{ExampleCode}
data(maize_des)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{maize\_des2}{Subset of design file of maize project, 313 samples are included.}{maize.Rul.des2}
%
\begin{Description}\relax
Subset of design file of maize project, 313 samples are included.
\end{Description}
%
\begin{Format}
A data frame with columns:
\begin{description}

\item[Sample\_ID] The unique ID of the microbial profiling sample.
\item[Host\_genotype] The genotype of the plant host maize.
\item[Compartment] The compartment of the microbial sample comes from.
\item[Soil] The soil of the sampled microbiome.
\item[Management] The management of the soil where microbial sample from.

\end{description}

\end{Format}
%
\begin{Source}\relax
RECONSTRUCT project, maize microbiome part.
\end{Source}
%
\begin{Examples}
\begin{ExampleCode}
data(maize_des2)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{mina-class}{Class "mina" includes the quantitative table and descriptive table.}{mina.Rdash.class}
%
\begin{Description}\relax
Class "mina" includes the quantitative table and descriptive table.
\end{Description}
%
\begin{Section}{Slots}

\begin{description}

\item[\code{tab}] The quantitative table of the dataset.

\item[\code{des}] The descriptive table of the samples listed in @tab.

\item[\code{norm}] The normalized quantitative table of @tab.

\item[\code{dis}] The distance / dissimilarity matrix between samples in @tab.

\item[\code{dmr}] The list of dimensionality reduction result, includes points and
variance.

\item[\code{adj}] The adjacency matrix between pairwise compositions (e.g. OTUs/ASVs)

\item[\code{adj\_sig}] The P-value matrix of adjacency matrix, only applicable for
Pearson and Spearman correlation adjacency matrices.

\item[\code{cls}] The cluster information for each composition.

\item[\code{cls\_tab}] The cluster quantitative table.

\item[\code{multi}] The list of subsampled adjacency matrices for each environment.

\item[\code{perm}] The list of permutated adjacency matrices for each pairwise
environmental comparison.

\item[\code{dis\_bs}] The distance between networks of different environmental
communities.

\item[\code{dis\_pm}] The distance between networks of permutated groups.

\item[\code{dis\_stat}] The average distance between subsampled environmental community
networks, permutated networks and corresponding significance.

\end{description}
\end{Section}
%
\begin{Author}\relax
Rui Guan \url{https://github.com/Guan06}
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv, des = maize_des)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{net\_cls}{Network clustering of sparsed adjacacency matrix @adj.}{net.Rul.cls}
%
\begin{Description}\relax
Network clustering of sparsed adjacacency matrix @adj.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
net_cls(x, method, cutoff = 0.4, neg = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @adj defined.

\item[\code{method}] The clustering method used.

\item[\code{cutoff}] The cutoff for the sparse adjacency matrix, default is 0.4.

\item[\code{neg}] Whether to keep the negative edges, default is `FALSE`.
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref", depth = 1000)
maize <- fit_tabs(maize)
maize <- adj(maize, method = "spearman")
maize <- net_cls(maize, method = "mcl", cutoff = 0.4, neg = FALSE)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{net\_cls,matrix,ANY-method}{Network clustering based on the sparsed adjacacency matrix @adj.}{net.Rul.cls,matrix,ANY.Rdash.method}
\aliasA{net\_cls,matrix,character-method}{net\_cls,matrix,ANY-method}{net.Rul.cls,matrix,character.Rdash.method}
%
\begin{Description}\relax
Network clustering based on the sparsed adjacacency matrix @adj.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'matrix,ANY'
net_cls(x, method, cutoff = 0.4, neg = FALSE)

## S4 method for signature 'matrix,character'
net_cls(x, method, cutoff = 0.4, neg = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Adjacency matrix used for clustering.

\item[\code{method}] The clustering method used.

\item[\code{cutoff}] The cutoff for the sparsed adjacacency matrix, default 0.4.

\item[\code{neg}] Whether to keep the negative edges, cannot be TRUE when using
`mcl` for clustering. Default FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
y The cluster table.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
asv_norm <- norm_tab(maize_asv2, method = "raref", depth = 1000)
asv_adj <- adj(asv_norm, method = "spearman")
asv_cls <- net_cls(asv_adj, method = "mcl")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{net\_cls,mina,ANY-method}{Network clustering based on the sparsed adjacacency matrix @adj.}{net.Rul.cls,mina,ANY.Rdash.method}
\aliasA{net\_cls,mina,character-method}{net\_cls,mina,ANY-method}{net.Rul.cls,mina,character.Rdash.method}
%
\begin{Description}\relax
Network clustering based on the sparsed adjacacency matrix @adj.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina,ANY'
net_cls(x, method, cutoff = 0.4, neg = FALSE)

## S4 method for signature 'mina,character'
net_cls(x, method, cutoff = 0.4, neg = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @adj defined.

\item[\code{method}] The clustering method used.

\item[\code{cutoff}] The cutoff for the sparsed adjacacency matrix, default 0.4.

\item[\code{neg}] Whether to keep the negative edges, cannot be TRUE when using
`mcl` for clustering. Default FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x The same `mina` class with @cls added.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref", depth = 1000)
maize <- fit_tabs(maize)
maize <- adj(maize, method = "spearman")
maize <- net_cls(maize, method = "mcl", cutoff = 0.4, neg = FALSE)
maize <- net_cls(maize, method = "ap", cutoff = 0.4, neg = FALSE)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{net\_cls\_tab}{Get the cluster table @cls\_tab from @norm and @cls.}{net.Rul.cls.Rul.tab}
%
\begin{Description}\relax
Get the cluster table @cls\_tab from @norm and @cls.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
net_cls_tab(x, uw = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @norm and @cls defined.

\item[\code{uw}] By summing up the number of present components of each cluster
instead of relative abundances, default is FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The network cluster relative abundance table.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref", depth = 1000)
maize <- fit_tabs(maize)
maize <- adj(maize, method = "spearman")
maize <- net_cls(maize, method = "ap", cutoff = 0.5)
maize <- net_cls_tab(maize)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{net\_cls\_tab,mina-method}{Get the cluster table @cls\_tab from quantitative table @norm and network clustering results @cls.}{net.Rul.cls.Rul.tab,mina.Rdash.method}
%
\begin{Description}\relax
Get the cluster table @cls\_tab from quantitative table @norm and network
clustering results @cls.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina'
net_cls_tab(x, uw = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @norm and @cls defined.

\item[\code{uw}] By summing up the number of present components of each cluster
instead of relative abundance, default is FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x The same `mina` object with @cls\_tab added.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref", depth = 1000)
maize <- fit_tabs(maize)
maize <- adj(maize, method = "spearman")
maize <- net_cls(maize, method = "mcl", cutoff = 0.5)
maize <- net_cls_tab(maize)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{net\_dis}{Calculate the network distance of @multi and test the significance when @perm is defined.}{net.Rul.dis}
%
\begin{Description}\relax
Calculate the network distance of @multi and test the significance when @perm
is defined.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
net_dis(x, method, evk = 100, egv = TRUE, dir = "./", sig = TRUE, skip = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @multi (and @perm if `sig` is TRUE)
defined.

\item[\code{method}] The distance to be calculated, "spectra" and "Jaccard" are
available.

\item[\code{evk}] The first `evk` eigenvalues will be used for `spectra` distance,
the default is 100.

\item[\code{egv}] Wheather to output the eigenvectors for Spectral distance, the
defult is TRUE, only validate when `method == "spectra"`.

\item[\code{dir}] The folder to output the eigenvectors, only validate when `egv ==
TRUE`, default is current path.

\item[\code{sig}] Whether to test the significance, if TRUE (by default), @perm is
needed.

\item[\code{skip}] Whether to skip the comparison when the dimenstion of adjacency
matrix is smaller than setted `evk`.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The netowrk comparison result.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- bs_pm(maize, group = "Compartment")
## Not run: 
maize <- net_dis(maize, method = "spectra", evk = 30)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{net\_dis\_indi}{Calculate the network distance of bootstrap and permutation when appliable.}{net.Rul.dis.Rul.indi}
\aliasA{net\_dis\_indi,character,ANY-method}{net\_dis\_indi}{net.Rul.dis.Rul.indi,character,ANY.Rdash.method}
\aliasA{net\_dis\_indi,character,character-method}{net\_dis\_indi}{net.Rul.dis.Rul.indi,character,character.Rdash.method}
%
\begin{Description}\relax
Calculate the network distance of bootstrap and permutation when appliable.

Calculate the network distance of bootstrap and permutation when appliable.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
net_dis_indi(x, method, evk = 100, sig = TRUE, skip = TRUE)

## S4 method for signature 'character,ANY'
net_dis_indi(x, method, evk = 100, sig = TRUE, skip = TRUE)

## S4 method for signature 'character,character'
net_dis_indi(x, method, evk = 100, sig = TRUE, skip = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The folder store the network inference results.
defined.

\item[\code{method}] The distance to be calculated, "spectra" and "Jaccard" are
available.

\item[\code{evk}] The first `evk` eigenvalues will be used for `spectra` distance,
the default is 100.

\item[\code{sig}] Whether to test the significance, if TRUE (by default),
permutation results should be included in the folder `x`.

\item[\code{skip}] Whether to skip the comparison when the dimenstion of adjacency
matrix is smaller than setted `evk`, default TRUE.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
y The `mina` object with @dis\_bs, @dis\_pm and @dis\_stat.

y The `mina` object with @dis\_bs, @dis\_pm and @dis\_stat.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
data(maize)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- bs_pm(maize, group = "Compartment", individual = TRUE, out_dir =
"./individual_bs_pm/")
maize_stat1 <- net_dis_indi(x = "./individual_bs_pm/", method = "spectra")
maize_stat2 <- net_dis_indi(x = "./individual_bs_pm/", method = "Jaccard")
maize_stat3 <- net_dis_indi(x = "./individual_bs_pm/", method = "spectra",
evk = 100, skip = TRUE)

## End(Not run)
## Not run: 
data(maize)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- bs_pm(maize, group = "Compartment", individual = TRUE, out_dir =
"./individual_bs_pm/")
maize_stat1 <- net_dis_indi("./individual_bs_pm/", method = "spectra")
maize_stat2 <- net_dis_indi("./individual_bs_pm/", method = "Jaccard")
maize_stat3 <- net_dis_indi("./individual_bs_pm/", method = "spectra",
evk = 100, skip = TRUE)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{net\_dis,mina,ANY-method}{Calculate the network distance of @multi and test the significance when @perm is defined.}{net.Rul.dis,mina,ANY.Rdash.method}
\aliasA{net\_dis,mina,character-method}{net\_dis,mina,ANY-method}{net.Rul.dis,mina,character.Rdash.method}
%
\begin{Description}\relax
Calculate the network distance of @multi and test the significance when @perm
is defined.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina,ANY'
net_dis(x, method, evk = 100, egv = TRUE, dir = "./", sig = TRUE, skip = TRUE)

## S4 method for signature 'mina,character'
net_dis(x, method, evk = 100, egv = TRUE, dir = "./", sig = TRUE, skip = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class `mina` with @multi (and @perm if sig is TRUE)
defined.

\item[\code{method}] The distance to be calculated, "spectra" and "Jaccard" are
available.

\item[\code{evk}] The first `evk` eigenvalues will be used for `spectra` distance,
the default is 100.

\item[\code{egv}] Wheather to output the eigenvectors for Spectral distance, the
defult is TRUE, only validate when `method == "spectra"`.

\item[\code{dir}] The folder to output the eigenvectors, only validate when `egv ==
TRUE`.

\item[\code{sig}] Whether to test the significance, if TRUE (by default), @perm is
needed.

\item[\code{skip}] Whether to skip the comparison when the dimenstion of adjacency
matrix is smaller than setted `evk`.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x The same `mina` object with @net\_dis defined.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- bs_pm(maize, group = "Compartment")
maize <- net_dis(maize, method = "Jaccard")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{norm\_tab}{Normalize the @tab and obtain @norm for later analysis.}{norm.Rul.tab}
%
\begin{Description}\relax
Normalize the @tab and obtain @norm for later analysis.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
norm_tab(x, method, depth = 1000, replace = TRUE, multi = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The input mina object with quantitative tab / a matrix needed to be
normalized.

\item[\code{method}] The method used for the normalization of quantitative table.

\item[\code{depth}] The depth for subsampling by rarefying, 1000 by default.

\item[\code{replace}] Whether to sample with replacement (\code{TRUE} by default) or
without replacement (\code{FALSE}) when using method `raref`.

\item[\code{multi}] Rarefy the table for multiple times, FALSE by default, indicate
the times of rarefaction want to be repeated, only validate for rarefaction.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Normalized quantitative table.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "total")
maize <- norm_tab(maize, method = "raref")
maize <- norm_tab(maize, method = "raref", depth = 1000, replace = TRUE)
maize <- norm_tab(maize, method = "raref", depth = 1000, replace = TRUE,
multi = 99)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{norm\_tab,matrix,character-method}{Normalize the quantitative matrix.}{norm.Rul.tab,matrix,character.Rdash.method}
%
\begin{Description}\relax
Normalize the quantitative matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'matrix,character'
norm_tab(x, method, depth = 1000, replace = TRUE, multi = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A quantitative matrix with samples in columns and compositions in
rows.

\item[\code{method}] The method used for normalization.

\item[\code{depth}] The depth for rarefying, 1000 by default.

\item[\code{replace}] Whether to sample with replacement (\code{TRUE} by default)
or without replacement (\code{FALSE}) when using method `raref`.

\item[\code{multi}] Rarefy the table for multiple times, FALSE by default, indicate
the times of rarefaction want to be repeated, only validate for rarefaction.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x\_norm Normalized matrix of the quantitative table.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data(maize_asv2)
maize_asv_norm <- norm_tab(maize_asv2, method = "total")
maize_asv_norm <- norm_tab(maize_asv2, method = "raref", depth = 1000,
replace = TRUE, multi = 3)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{norm\_tab\_method\_list}{List of normalization methods supported in \code{\LinkA{norm\_tab}{norm.Rul.tab}}}{norm.Rul.tab.Rul.method.Rul.list}
\keyword{datasets}{norm\_tab\_method\_list}
%
\begin{Description}\relax
Normalization methods should be specified by exact string match.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
norm_tab_method_list
\end{verbatim}
\end{Usage}
%
\begin{Format}
A list of character vectors.
\begin{description}

\item[\code{raref}]  By downsampling all samples to specific depth. 
\item[\code{total}]  Devided by the total read of each sample. 

\end{description}

\end{Format}
%
\begin{SeeAlso}\relax
\code{\LinkA{norm\_tab}{norm.Rul.tab}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
? norm_tab_method_list
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{norm\_tab,mina,ANY-method}{Normalize the quantitative table with mina input.}{norm.Rul.tab,mina,ANY.Rdash.method}
\aliasA{norm\_tab,mina,character-method}{norm\_tab,mina,ANY-method}{norm.Rul.tab,mina,character.Rdash.method}
%
\begin{Description}\relax
Normalize the quantitative table with mina input.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'mina,ANY'
norm_tab(x, method, depth = 1000, replace = TRUE, multi = FALSE)

## S4 method for signature 'mina,character'
norm_tab(x, method, depth = 1000, replace = TRUE, multi = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of the class mina with @tab defined.

\item[\code{method}] The method used for normalization.

\item[\code{depth}] The depth for subsampling by rarefying, 1000 by default.

\item[\code{replace}] Whether to sample with replacement (\code{TRUE} by default) or
without replacement (\code{FALSE}) when using method `raref`.

\item[\code{multi}] Rarefy the table for multiple times, FALSE by default, indicate
the times of rarefaction want to be repeated, only validate for rarefaction.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
x An object of the class mina with @norm added.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref", depth = 1000, replace = TRUE,
multi = 3)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{pcoa\_plot}{Visulization of components distance / dissimilarity in k dimension.}{pcoa.Rul.plot}
%
\begin{Description}\relax
Visulization of components distance / dissimilarity in k dimension.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pcoa_plot(x, des, match, d1 = 1, d2 = 2, color, shape = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A list generated by `dmr`.

\item[\code{des}] The corresponding descriptive table.

\item[\code{match}] The column name of the components IDs in `des` with exactly the
same as rownames in x.

\item[\code{d1}] The dimension be visualized in x-axis, default `1`.

\item[\code{d2}] The dimension be visualized in y-axis, default `2`.

\item[\code{color}] The column name in `des` to be used for different color groups.

\item[\code{shape}] The column name in `des` to be used for different shape groups,
default `NULL`.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
p The plotted figure.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
maize <- dmr(maize)
asv_dmr <- maize@dmr
des <- maize@des
p1a <- pcoa_plot(asv_dmr, des, match = "Sample_ID", color = "Compartment")
p1b <- pcoa_plot(asv_dmr, des, match = "Sample_ID", d1 = 3, d2 = 4, color =
"Compartment")
p2a <- pcoa_plot(asv_dmr, des, match = "Sample_ID", color = "Host_genotype")
p2b <- pcoa_plot(asv_dmr, des, match = "Sample_ID", d1 = 1, d2 = 3, color =
"Host_genotype")
p3a <- pcoa_plot(asv_dmr, des, match = "Sample_ID", color = "Compartment",
shape = "Soil")
p3b <- pcoa_plot(asv_dmr, des, match = "Sample_ID", d1 = 1, d2 = 4, color =
"Compartment", shape = "Soil")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{pcoa\_plot,list,data.frame,character,ANY,ANY,character-method}{Visulization of components distance / dissimilarity in k dimension.}{pcoa.Rul.plot,list,data.frame,character,ANY,ANY,character.Rdash.method}
%
\begin{Description}\relax
Visulization of components distance / dissimilarity in k dimension.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'list,data.frame,character,ANY,ANY,character'
pcoa_plot(x, des, match, d1 = 1, d2 = 2, color, shape = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A list generated by `dmr`.

\item[\code{des}] The corresponding descriptive table.

\item[\code{match}] The column name of the components IDs in `des` with exactly the
same as rownames in x.

\item[\code{d1}] The dimension be visualized in x-axis, default `1`.

\item[\code{d2}] The dimension be visualized in y-axis, default `2`.

\item[\code{color}] The column name in `des` to be used for different color groups.

\item[\code{shape}] The column name in `des` to be used for different shape groups,
default `NULL`.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
p The plotted figure.

The PCoA plot.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
maize <- new("mina", tab = maize_asv2, des = maize_des2)
maize <- norm_tab(maize, method = "raref")
maize <- fit_tabs(maize)
maize <- com_dis(maize, method = "bray")
maize <- dmr(maize)
asv_dmr <- maize@dmr
des <- maize@des
p1a <- pcoa_plot(asv_dmr, des, match = "Sample_ID", color = "Compartment")
p1b <- pcoa_plot(asv_dmr, des, match = "Sample_ID", d1 = 3, d2 = 4, color =
"Compartment")
p2a <- pcoa_plot(asv_dmr, des, match = "Sample_ID", color = "Host_genotype")
p2b <- pcoa_plot(asv_dmr, des, match = "Sample_ID", d1 = 1, d2 = 3, color =
"Host_genotype")
p3a <- pcoa_plot(asv_dmr, des, match = "Sample_ID", color = "Compartment",
shape = "Soil")
p3b <- pcoa_plot(asv_dmr, des, match = "Sample_ID", d1 = 1, d2 = 4, color =
"Compartment", shape = "Soil")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{tina}{TINA community dissimilarity used in \code{\LinkA{com\_dis}{com.Rul.dis}}. Function for `tina` dissimilarity/distance calculation. Modified from Schmidt et al., 2016.}{tina}
%
\begin{Description}\relax
TINA community dissimilarity used in \code{\LinkA{com\_dis}{com.Rul.dis}}.
Function for `tina` dissimilarity/distance calculation. Modified from Schmidt
et al., 2016.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
tina(
  x,
  cor_method = "spearman",
  sim_method = "w_ja",
  threads = 80,
  nblocks = 400
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An matrix for dissimilarity calculation.

\item[\code{cor\_method}] The method for correlation, "pearson" and "spearman" are
available.

\item[\code{sim\_method}] The method for similarity, "w\_ja" and "uw\_ja" are
available for weighted and unweighted Jaccard similarity respectively.

\item[\code{threads}] The number of threads used for parallel running, 80 by
default.

\item[\code{nblocks}] The number of row / column for splitted sub-matrix, 400 by
default.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The output `tina` dissimilarity matrix.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
asv_norm <- norm_tab(maize_asv2, method = "raref", depth = 1000)
asv_dis <- com_dis(asv_norm, method = "bray")
asv_dis <- com_dis(asv_norm, method = "tina", threads = 8, nblocks = 40)
asv_tina <- tina(asv_norm, cor_method = "spearman", sim_method = "w_ja",
threads = 8, nblocks = 40)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{tina,matrix,character,character-method}{Function for `tina` dissimilarity calculation. Modified from Schmidt et al., 2016. Person and Spearman could be used for correlation and weighted and unweighted Jaccard could be used for similarity calculation.}{tina,matrix,character,character.Rdash.method}
%
\begin{Description}\relax
Function for `tina` dissimilarity calculation. Modified from Schmidt et al.,
2016. Person and Spearman could be used for correlation and weighted and
unweighted Jaccard could be used for similarity calculation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'matrix,character,character'
tina(
  x,
  cor_method = "spearman",
  sim_method = "w_ja",
  threads = 80,
  nblocks = 400
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A matrix for dissimilarity calculation.

\item[\code{cor\_method}] The method for correlation, "pearson" and "spearman" are
available.

\item[\code{sim\_method}] The method for similarity, "w\_ja" and "uw\_ja" are
available for weighted and unweighted Jaccard similarity respectively.

\item[\code{threads}] The number of threads used for parallel running, 80 by
default.

\item[\code{nblocks}] The number of row and column for splitted sub-matrix, 400 by
default.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
t The output `tina` dissimilarity matrix.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
asv_norm <- norm_tab(maize_asv2, method = "raref", depth = 1000)
asv_dis <- com_dis(asv_norm, method = "bray")
asv_dis <- com_dis(asv_norm, method = "tina", threads = 8, nblocks = 40)
asv_tina <- tina(asv_norm, cor_method = "spearman", sim_method = "w_ja",
threads = 8, nblocks = 40)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
